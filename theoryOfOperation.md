<!-- ABOUT THE PROJECT -->
### This document contains further discussion on the theory of operation for the FPGA MIDI Controller project. For an overview of the project or an understanding of how to implement it yourself, please see the README. 

##Project Overview 
* This project contains the source code which allows for a fully-functional, polyphonic MIDI keyboard connected to an FPGA with an audio output. 
* The appendices.pdf contains block diagrams of the logic and state diagrams which served as the logical basis for the VHDL written. 
* This project was implemented on a Basys3 FPGA in Xilinx Vivado 2018

## Built With

* [VHDL](https://www.seas.upenn.edu/~ese171/vhdl/vhdl_primer.html) - The VHSIC Hardware Description Language is a hardware description language that can model the behavior and structure of digital systems at multiple levels of abstraction, ranging from the system level down to that of logic gates, for design entry, documentation, and verification purposes
* [Xilinx Vivado](https://www.xilinx.com/support/download.html) - Vivado Design Suite is a software suite produced by Xilinx for synthesis and analysis of HDL design

## Introduction + Implementation Instructions 
[Please see README](https://github.com/arnavtolat/Midi-Keyboard-VHDL/blob/22cc481082bb61794425cf64bf8b394caf01a1cf/README.md)

## Theory of Operation

At a high level, the system functions by taking a digital signal from the MIDI keyboard and converting it to an analog sine wave, corresponding to the frequency of the key pressed on the MIDI keyboard. The system’s core blocks are a MIDI keyboard interface block, a note synthesizer block, a DDS phase accumulator block, and a digital to analog converter controller block. Each of these blocks is described in depth in the appendices: diagrams can be found in Appendix 1, while VHDL code and state diagrams can be found in Appendix 2. The high-level behavior of the system is modelled by Figures 1.2.1 and 1.2.2 in the appendices.
The MIDI keyboard interface block’s core function is to take in and store the data sent to it from the MIDI keyboard. To this end, the block takes in data input from the keyboard via the data input port as can be seen in Figure 1.2.5, and outputs to the synthesizer knowledge of which notes should be turned on (that is, counted in the final accumulated frequency sent to the D-to-A converter). The block functions as a shift register, which waits for a 10-bit message (8 bits, start bit, and stop bit) containing data to arrive from the MIDI keyboard. Note the MIDI keyboard’s three byte message structure, wherein the first byte of a message works as follows. On key press, the first byte of the message from the MIDI keyboard signals that a note is turned on, the second byte of the message contains information regarding which key was pressed, and the third byte of the message contains velocity information (which we did not use in this project). On key release, the first byte signals that a note was released, the second byte signals which note was released, and the third byte is simply padding. In order to interpret this information, the MIDI keyboard block first synchronizes the input using a D-flop synchronizer. It then engages in programmed logic as described in Appendix 2.1.3, where it waits, shifts, loads, and interprets each message, storing each byte of the message in the messages register. After the message has been fully loaded into the register, on the interpret state the block updates the notes_out register based on the note sent in. It then reverts to the idle state and waits for new input from the keyboard.

The synthesizer block’s function is to run phase accumulators for each possible note on the keyboard, and prepare the data to be sent to the digital to analog converter. Each DDS phase accumulator component is simply a counter with a predefined step size, corresponding to the desired frequency for the note (each frequency must be a multiple of 1.465 Hz, as described in Appendix 3). This behavior allows the system to seamlessly play a sound corresponding to the key(s) pressed. The programmed logic for this block is described in Appendix 2.1.2. The synthesizer module also contains a single sine wave LUT, as can be seen in the block diagram in Appendix 1.2.4. The synthesizer uses the custom DDS components to generate ongoing counts for each note, based on the step size for the phase accumulator. When the controller engages the “noting” state, the component then starts to convert these counts to a sine wave value (using the LUT), sums the sine waves together (which are stored in the notes register) and normalizes the final note output by dividing the sum by the total number of notes being played. (The internal count_to_data and count_to_sin processes take care of conversion from two’s complement to offset binary.) This process functionally enables polyphony with an unlimited number of notes. This block also generates the output for the 7-segment display, corresponding to the MIDI code of the highest note pressed.

The digital analog converter block’s function is essentially a reversal of the analog to digital converter designed in Lab 6. A detailed diagram of this block is shown in Figure 1.2.2. The converter takes in a 15-bit digital signal generated by the synthesizer block, and converts it to a serial data output using a shift register with a controller. The serial data, chip select, and clock outputs are then wired to the JA pins on the Basys 3 board, which connects to the inputs of the Pmod DA2.


<p align="right">(<a href="#top">back to top</a>)</p>
